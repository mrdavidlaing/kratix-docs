"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[3170],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",k={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,d=c["".concat(s,".").concat(m)]||c[m]||k[m]||l;return n?a.createElement(d,o(o({ref:t},p),{},{components:n})):a.createElement(d,o({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3189:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const l={description:"Create and configure a Worker cluster, and install a Promise",title:"Installing a Promise",id:"installing-a-promise",slug:"../installing-a-promise"},o=void 0,i={unversionedId:"workshop/part-i/installing-a-promise",id:"workshop/part-i/installing-a-promise",title:"Installing a Promise",description:"Create and configure a Worker cluster, and install a Promise",source:"@site/docs/workshop/part-i/02-installing-a-promise.md",sourceDirName:"workshop/part-i",slug:"/workshop/installing-a-promise",permalink:"/docs/workshop/installing-a-promise",draft:!1,editUrl:"https://github.com/syntasso/kratix-docs/tree/main/docs/workshop/part-i/02-installing-a-promise.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{description:"Create and configure a Worker cluster, and install a Promise",title:"Installing a Promise",id:"installing-a-promise",slug:"../installing-a-promise"},sidebar:"workshopSidebar",previous:{title:"Installing Kratix",permalink:"/docs/workshop/installing-kratix"},next:{title:"Unpacking a Promise",permalink:"/docs/workshop/promise-theory"}},s={},u=[{value:"What&#39;s a Promise?",id:"promise-definition",level:2},{value:"Provide Jenkins-as-a-Service",id:"install-jenkins",level:2},{value:"Set up a Worker Cluster",id:"configure-worker",level:2},{value:"Create the cluster",id:"create-the-cluster",level:3},{value:"Configure the cluster",id:"configure-the-cluster",level:3},{value:"Register the cluster with Kratix",id:"register-the-cluster-with-kratix",level:3},{value:"Request a Jenkins Instance",id:"request-jenkins",level:2},{value:"Clean up",id:"clean-up",level:2},{value:"Summary",id:"summary",level:2},{value:"\ud83c\udf89 \xa0 Congratulations!",id:"--congratulations",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This is Part 2 of ",(0,r.kt)("a",{parentName:"p",href:"intro"},"a series")," illustrating how Kratix works. ",(0,r.kt)("br",null),"\n\ud83d\udc48\ud83c\udffe","\xa0","\xa0"," Previous: ",(0,r.kt)("a",{parentName:"p",href:"installing-kratix"},"Install Kratix")," ",(0,r.kt)("br",null),"\n\ud83d\udc49\ud83c\udffe","\xa0","\xa0"," Next: ",(0,r.kt)("a",{parentName:"p",href:"promise-theory"},"Unpacking a Promise")),(0,r.kt)("hr",null),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"in this tutorial, you will")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#promise-definition"},"learn what Promises are")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#install-jenkins"},"install your first Kratix Promise")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#configure-worker"},"learn about configuring a Worker cluster")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#request-jenkins"},"request an instance of the Promised service"))),(0,r.kt)("p",null,"Following the ",(0,r.kt)("a",{parentName:"p",href:"installing-kratix"},"Installing Kratix")," tutorial, you should now\nhave a deployment of both Kratix and MinIO running on your Platform cluster.\nVerify the current state of your installation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get deployments --namespace kratix-platform-system\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                                 READY   UP-TO-DATE   AVAILABLE   AGE\nkratix-platform-controller-manager   1/1     1            1           1h\nminio                                1/1     1            1           1h\n")),(0,r.kt)("p",null,"You should also have a State Store created and configured to point to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"kratix")," bucket on MinIO. Verify the ",(0,r.kt)("inlineCode",{parentName:"p"},"bucketstatestores"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get bucketstatestores.platform.kratix.io\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME          AGE\nminio-store   1h\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"To check the configuration parameters, run:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform \\\n   describe bucketstatestore minio-store\n"))),(0,r.kt)("p",null,"If your outputs do not align with the expected, please refer back to\n",(0,r.kt)("a",{parentName:"p",href:"installing-kratix"},"Installing Kratix"),"."),(0,r.kt)("p",null,"With that, you have all the pieces you need to install your first Promise!"),(0,r.kt)("h2",{id:"promise-definition"},"What's a Promise?"),(0,r.kt)("p",null,"A Promise is the building block that Kratix provides to enable Platform teams to\nbuild their platforms incrementally. Promises are what allow the Platform to\nprovide anything-as-a-Service, and are composed of mainly three pieces:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A set of dependencies that needs to be installed on any Worker cluster\nintending to run the Promise workload."),(0,r.kt)("li",{parentName:"ul"},"An API exposing to the user of the Platform the configuration options they\nhave when requesting the service provided by the Promise."),(0,r.kt)("li",{parentName:"ul"},"A series of steps that need to be executed to fulfill the Promise and create\nthe service.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83e\udd14 How's that different from Helm? Or Crossplane? Or... "),(0,r.kt)("p",null,"Kratix positions itself as a framework for building Platforms. Instead of\nthinkins ",(0,r.kt)("em",{parentName:"p"},"Kratix or X"),", think ",(0,r.kt)("strong",{parentName:"p"},"Kratix and X"),". The team has written\nextensively on how Kratix can work together with other Kubernetes tools.\nPlease check ",(0,r.kt)("a",{parentName:"p",href:"https://kratix.io/docs/main/value-of-kratix#collaboration-with-other-tools"},"The Value of\nKratix"),"\nfor details.")),(0,r.kt)("p",null,"In the ",(0,r.kt)("a",{parentName:"p",href:"promise-theory"},"next section"),", we'll unpack what's inside a Promise and explain the theory\nbehind it."),(0,r.kt)("h2",{id:"install-jenkins"},"Provide Jenkins-as-a-Service"),(0,r.kt)("p",null,"In this tutorial, we will provide Jenkins-as-a-Service in the Platform, making\nit available on-demand for the developers using it."),(0,r.kt)("p",null,"This tutorial will focus on making Jenkins-as-a-Service available, on-demand,\nfor developers using the Platform. Kratix offers a variety of ready-to-use\nPromises in the ",(0,r.kt)("a",{parentName:"p",href:"/marketplace"},"Kratix Marketplace"),", including a Jenkins Promise\nthat we can utilize to complete this task. By following the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/syntasso/kratix-marketplace/tree/main/jenkins"},"Promise\ndocumentation"),",\nyou can find the installation steps."),(0,r.kt)("p",null,"Install the Jenkins Promise:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply \\\n   --context kind-platform \\\n   --filename https://raw.githubusercontent.com/syntasso/kratix-marketplace/main/jenkins/promise.yaml\n")),(0,r.kt)("p",null,"And that's it! Promise installed!"),(0,r.kt)("p",null,"However, if you look closely, the Kratix controller will be complaining:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'kubectl --context kind-platform --namespace kratix-platform-system \\\n  logs deployment/kratix-platform-controller-manager \\\n  --container manager | grep "Reconciler error"\n')),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},'# output formatted for readability\nERROR   Reconciler error {\n    "Work": {"name":"jenkins-default","namespace":"default"},\n    "error": "no Clusters can be selected for clusterSelector"\n}\n')),(0,r.kt)("p",null,"To better explain what's going on, let's go through what just happens when\nKratix receives a request."),(0,r.kt)("p",null,"When a Promise is installed, or when a service is requested, Kratix reacts by\ncreating a ",(0,r.kt)("em",{parentName:"p"},"Work"),"."),(0,r.kt)("p",null,"Verify the Works created with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get works.platform.kratix.io\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME              AGE\njenkins-default   1h\n")),(0,r.kt)("p",null,"Once a Work is created, the Kratix Scheduler kicks in. It tries to find a\ncluster that can run the workload defined in the Work. However, at present, we\nhaven't registered any Clusters with Kratix, so it cannot schedule the workload\njust yet."),(0,r.kt)("p",null,"Verify the registered clusters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get clusters.platform.kratix.io --all-namespaces\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"No resources found\n")),(0,r.kt)("p",null,"So, to fix the error, we must register a new Cluster. Let's do that now."),(0,r.kt)("h2",{id:"configure-worker"},"Set up a Worker Cluster"),(0,r.kt)("h3",{id:"create-the-cluster"},"Create the cluster"),(0,r.kt)("p",null,"We'll create a second Kubernetes cluster with ",(0,r.kt)("inlineCode",{parentName:"p"},"kind"),", and this cluster will be\ndedicated to running the Kratix workloads."),(0,r.kt)("p",null,"From the ",(0,r.kt)("inlineCode",{parentName:"p"},"kratix")," directory, create a new cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kind create cluster --name worker \\\n    --image kindest/node:v1.24.0 \\\n     --config config/samples/kind-worker-config.yaml\n")),(0,r.kt)("p",null,"Similar to when we created the Plaform cluster, ",(0,r.kt)("inlineCode",{parentName:"p"},"kind")," will update your local\nconfiguration with the details to access the worker cluster. We are also\nproviding ",(0,r.kt)("inlineCode",{parentName:"p"},"kind")," with a configuration file to facilitate accessing the deployed\nservices later on."),(0,r.kt)("p",null,"Once the creation completes, you can reach your worker cluster on the\n",(0,r.kt)("inlineCode",{parentName:"p"},"kind-worker")," context."),(0,r.kt)("p",null,"Verify the cluster is ready:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-worker cluster-info\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"Kubernetes control plane is running at https://127.0.0.1:YYYYY\nCoreDNS is running at https://127.0.0.1:59160/api/v1/...\n\nTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.\n")),(0,r.kt)("p",null,"Before registering the Worker cluster with the Platform, let's make it ready to\nreceive the workloads."),(0,r.kt)("h3",{id:"configure-the-cluster"},"Configure the cluster"),(0,r.kt)("p",null,"Kratix schedules works by writing a state declaration (following Kubernetes\ndeclare-and-converge pattern) to the designated State Store. When it comes to\nreconciling the declared state, Kratix remains agnostic about the specific tool\nto be used on the clusters. In this tutorial, we will utilise\n",(0,r.kt)("a",{parentName:"p",href:"https://fluxcd.io/"},"Flux")," on the Worker, and configure it to reconcile the\nstate from the MinIO bucket."),(0,r.kt)("p",null,"To install and configure Flux, run the following script from the Kratix\nrepository:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"./scripts/install-gitops --context kind-worker --path worker-cluster\n")),(0,r.kt)("p",null,"The script above will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Install Flux"),(0,r.kt)("li",{parentName:"ul"},"Create a new Flux ",(0,r.kt)("inlineCode",{parentName:"li"},"Bucket")," Source"),(0,r.kt)("li",{parentName:"ul"},"Create two Flux ",(0,r.kt)("inlineCode",{parentName:"li"},"Kustomizations"))),(0,r.kt)("p",null,"The Flux ",(0,r.kt)("inlineCode",{parentName:"p"},"Kustomizations")," are responsible for continuously reconciling with the state\ndeclared in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Source"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Configuring the Worker Cluster: the manual way"),(0,r.kt)("p",null,"If you prefer to configure the Worker cluster manually, follow the steps below."),(0,r.kt)("p",null,"Install Flux on the Worker cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply \\\n   --context kind-worker \\\n   --filename https://github.com/fluxcd/flux2/releases/download/v2.0.0-rc.3/install.yaml\n")),(0,r.kt)("p",null,"Next, let's tell Flux about the MinIO bucket. For that, we will create a new\nFlux ",(0,r.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/source/buckets/"},"Bucket Source"),",\ntogether with a Secret containing the bucket credentials."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"You may notice that the value of the Bucket ",(0,r.kt)("inlineCode",{parentName:"p"},"endpoint")," on the document below is\nset to ",(0,r.kt)("inlineCode",{parentName:"p"},"172.18.0.2:31337"),". Since the MinIO server is running on the Platform\ncluster, and we want to access it from the Worker cluster, we cannot leverage\nKubernetes DNS as we did in the previous tutorial."),(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"172.18.0.2")," will often be the address of the Platform cluster running on KinD.\nPlease make sure to double check this address."),(0,r.kt)("p",{parentName:"admonition"},"Verify the Platform control-plane IP:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker inspect platform-control-plane | grep '\"IPAddress\": \"172' | awk -F '\"' '{print $4}'\n")),(0,r.kt)("p",{parentName:"admonition"},"The above command will give an output similar to:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"172.18.0.2\n")),(0,r.kt)("p",{parentName:"admonition"},"If the command above outputs a different IP, make sure to update the Bucket\nconfiguration below accordingly."),(0,r.kt)("p",{parentName:"admonition"},"The port part of the endpoint should always be 31337. Verify the NodePort of the\nMinIO service in the Platform cluster:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get services minio --namespace kratix-platform-system\n")),(0,r.kt)("p",{parentName:"admonition"},"The above command will give an output similar to:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME    TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE\nminio   NodePort   10.96.45.28   <none>        80:31337/TCP   1h\n"))),(0,r.kt)("p",null,"Create the Flux Source Bucket (and Secret):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"cat <<EOF | kubectl --context kind-worker apply -f -\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: minio-credentials\n  namespace: flux-system\ntype: Opaque\nstringData:\n  accesskey: minioadmin\n  secretkey: minioadmin\n---\napiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: Bucket\nmetadata:\n  name: kratix-bucket\n  namespace: flux-system\nspec:\n  interval: 10s\n  provider: generic\n  bucketName: kratix\n  endpoint: 172.18.0.2:31337 # make sure to read the caution box above\n  insecure: true\n  secretRef:\n    name: minio-credentials\nEOF\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"secret/minio-credentials created\nbucket.source.toolkit.fluxcd.io/kratix-bucket created\n")),(0,r.kt)("p",null,"We won't dive into details of how to configure Flux Sources, but please read on their\n",(0,r.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/source/"},"documentation")," if you are curious."),(0,r.kt)("p",null,"Once the Bucket Source is created, validates Flux can reach the bucket:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-worker get buckets.source.toolkit.fluxcd.io --namespace flux-system\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME            ENDPOINT           AGE     READY   STATUS\nkratix-bucket   172.18.0.2:31337   1h      True    stored artifact: revision 'sha256:some-sha'\n")),(0,r.kt)("p",null,"Next, you must tell Flux what is must do with this Source. Flux does continuous\ndelivery through the ",(0,r.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/kustomize/"},"Kustomize\nController"),". You can define a Flux\n",(0,r.kt)("inlineCode",{parentName:"p"},"Kustomization")," that watches for a Source and reconciles on events."),(0,r.kt)("p",null,"Create the Flux Kustomizations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"cat <<EOF | kubectl --context kind-worker apply --filename -\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: kratix-workload-crds\n  namespace: flux-system\nspec:\n  interval: 8s\n  prune: true\n  sourceRef:\n    kind: Bucket\n    name: kratix-bucket\n  path: ./default/worker-cluster/crds\n---\napiVersion: kustomize.toolkit.fluxcd.io/v1\nkind: Kustomization\nmetadata:\n  name: kratix-workload-resources\n  namespace: flux-system\nspec:\n  interval: 3s\n  prune: true\n  dependsOn:\n  - name: kratix-workload-crds\n  sourceRef:\n    kind: Bucket\n    name: kratix-bucket\n  path: ./default/worker-cluster/resources\nEOF\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"kustomization.kustomize.toolkit.fluxcd.io/kratix-workload-crds created\nkustomization.kustomize.toolkit.fluxcd.io/kratix-workload-resources created\n")),(0,r.kt)("p",null,"You will notice that we are creating two Kustomizations. When scheduling\nWorks, Kratix will separate the documents based on their GVK (Group, Version,\nKind):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Custom Resource Definition (as defined\n",(0,r.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#customresourcedefinition-v1-apiextensions-k8s-io"},"here"),")\nwill be written to a specific ",(0,r.kt)("inlineCode",{parentName:"li"},"crds")," path within the State Store."),(0,r.kt)("li",{parentName:"ul"},"All other documents will be written to a specific ",(0,r.kt)("inlineCode",{parentName:"li"},"resources")," path within the\nState Store.")),(0,r.kt)("p",null,"When we later on register the Cluster, Kratix will use the cluster's ",(0,r.kt)("inlineCode",{parentName:"p"},"namespace"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," to build the full path for that cluster within the State Store."),(0,r.kt)("p",null,"The first Kustomization above is for the CRDs, while the second is for the other\nresources (note the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.path"),"). You can also note that the\n",(0,r.kt)("inlineCode",{parentName:"p"},"kratix-workload-resources")," depends on the ",(0,r.kt)("inlineCode",{parentName:"p"},"kratix-workload-crds"),". That's to\navoid failures when a resource documents uses a GVK being defined by a CRD\ndocument."),(0,r.kt)("p",null,"For further details on the naming convention for the buckets and paths, check\nthe ",(0,r.kt)("a",{parentName:"p",href:"../main/reference/statestore/intro"},"documentation"),". For more on\nKustomizations, check ",(0,r.kt)("a",{parentName:"p",href:"https://fluxcd.io/flux/components/kustomize/kustomization/"},"the Flux docs\npage"))),(0,r.kt)("p",null,"Once Flux finishes starting, verify the status of the Kustomizations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-worker get kustomizations.kustomize.toolkit.fluxcd.io --namespace flux-system --watch\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"kubectl")," commands with the ",(0,r.kt)("inlineCode",{parentName:"p"},"--watch")," flag block your terminal indefinetely. To\nexit the watch mode, press ",(0,r.kt)("kbd",null,"Ctrl"),"+",(0,r.kt)("kbd",null,"C"),".")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                        AGE   READY   STATUS\nkratix-workload-crds        20s   False   kustomization path not found: stat /tmp/kustomization-540356764/default/worker-cluster/crds: no such file or directory\nkratix-workload-resources   20s   False   dependency 'flux-system/kratix-workload-crds' is not ready\n")),(0,r.kt)("p",null,"As you can see, Flux is not able to reconcile the state right now. That's\nbecause the path within the bucket does not exist yet. As mentioned, Kratix will\ncreate it when the cluster is registered."),(0,r.kt)("h3",{id:"register-the-cluster-with-kratix"},"Register the cluster with Kratix"),(0,r.kt)("p",null,"With the Worker cluster ready, we can now register it with Kratix. Note that the\norder of operations here is not important; we could've registered the Worker\nfirst and then followed th steps above. Kratix would've scheduled to the State\nStore, and the state would eventually be applied to a Worker."),(0,r.kt)("p",null,"To register a cluster, create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Cluster")," object on your Platform cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"cat <<EOF | kubectl --context kind-platform apply --filename -\napiVersion: platform.kratix.io/v1alpha1\nkind: Cluster\nmetadata:\n   name: worker-cluster\n   namespace: default\n   labels:\n    environment: dev\nspec:\n   stateStoreRef:\n      name: minio-store\n      kind: BucketStateStore\nEOF\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"cluster.platform.kratix.io/worker-cluster created\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Cluster in detail"),(0,r.kt)("p",null,"The Kratix Cluster Resource is the representation of a system where workloads\ncan be scheduled to. Those system are usually other Kubernetes clusters."),(0,r.kt)("p",null,"The only required field is ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.stateStoreRef"),". It contains a reference to a State\nStore present in the Platform. In our example, it points to the ",(0,r.kt)("inlineCode",{parentName:"p"},"minio-store"),"\nobject we created on the previous step. The ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.StateStoreRef.kind")," determines\nwhat is the kind of State Store being used by this Cluster."),(0,r.kt)("p",null,"That means different Clusters can use different backing storage. For example,\nyou can have a set of Clusters backed by Git, while another set of Clusters can\nbe backed by a Bucket. Further configuration options pertaining paths are also\navailable both in the ",(0,r.kt)("a",{parentName:"p",href:"../main/reference/statestore/intro"},"State Store")," and the\n",(0,r.kt)("a",{parentName:"p",href:"../main/reference/clusters/intro"},"Cluster object"),".")),(0,r.kt)("p",null,"With the Cluster registered, Kratix now have a place where it can run workloads.\nIf you fetch the WorkPlacements, you should see that the Jenkins Promise has now\nbeen scheduled to the Worker cluster."),(0,r.kt)("p",null,"Verify the Work Placements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get workplacements.platform.kratix.io\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                             AGE\njenkins-default.worker-cluster   1h\n")),(0,r.kt)("p",null,"That means that all the dependencies the Jenkins Promise needs to fulfill a\nJenkins request are now penciled to be installed in the Worker cluster. One of\nthe dependencies for the Jenkins Promise is the Jenkins Operator itself."),(0,r.kt)("p",null,"Verify that the Jenkins Operator starts in the Worker cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"kubectl --context kind-worker get deployments --watch\n")),(0,r.kt)("p",null,"The above command will give an output similar to (it may take a couple of\nminutes):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME               READY   UP-TO-DATE   AVAILABLE   AGE\njenkins-operator   0/1     0            0           0s\njenkins-operator   0/1     0            0           0s\njenkins-operator   0/1     0            0           0s\njenkins-operator   0/1     1            0           0s\njenkins-operator   1/1     1            1           11s\n")),(0,r.kt)("p",null,"If at this stage we create another Kubernetes cluster and follow similar steps\nas the above, the Jenkins Promise dependencies would also be installed on the\nnew Worker cluster. We will later on see how we can nudge Kratix to only make\ncertain Promises available in certain clusters."),(0,r.kt)("p",null,"Great! The Jenkins Promise installation is now complete. Let's switch roles for\na moment and become the developer requesting a new Jenkins instance."),(0,r.kt)("h2",{id:"request-jenkins"},"Request a Jenkins Instance"),(0,r.kt)("p",null,"As a user of the Platform, you can find out what's available by checking the\ninstalled Promises:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get promises.platform.kratix.io\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME      AGE\njenkins   1h\n")),(0,r.kt)("p",null,"To request a Jenkins instance, all you need is to send a new Jenkins Resource\nRequest to the Platform."),(0,r.kt)("p",null,"Create a Jenkins Instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"cat <<EOF | kubectl --context kind-platform apply --filename -\napiVersion: marketplace.kratix.io/v1alpha1\nkind: jenkins\nmetadata:\n  name: example\n  namespace: default\nspec:\n  env: dev\nEOF\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"jenkins.marketplace.kratix.io/example created\n")),(0,r.kt)("p",null,"When writing the Resource Request, the Platform user will have all the\nconfiguration options exposed to them as part of the Promise API, as defined by\nthe Platform team. The Jenkins Promise we are using is exposing a single\nconfiguration option: ",(0,r.kt)("inlineCode",{parentName:"p"},"spec.env")," (see the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/syntasso/kratix-marketplace/tree/main/jenkins"},"Jenkins Promise\ndocumentation"),").\nWhen set to ",(0,r.kt)("inlineCode",{parentName:"p"},"prod"),", the resulting instance will have backups enabled."),(0,r.kt)("p",null,"Once Kratix receives the request, it will create a new Work."),(0,r.kt)("p",null,"Verify the Works (it may take a couple of minutes for the new Work to appear):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get works.platform.kratix.io --watch\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                              AGE\njenkins-default                   1h\n//highlight-next-line\njenkins-default-default-example   1m\n")),(0,r.kt)("p",null,"Once the Work is created, Kratix will look for available clusters and determine\nwhere the Workload should be scheduled. As we only have on cluster registered,\nit will be scheduled to that cluster."),(0,r.kt)("p",null,"Verify the Work Placements:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform get workplacements.platform.kratix.io --watch\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                                               AGE\n//highlight-next-line\njenkins-default-default-example.worker-cluster     1m\njenkins-default.worker-cluster                     1h\n")),(0,r.kt)("p",null,"Kratix will then write the documents to the directory within the bucket that the\nWorker cluster is watching. You will soon see the Jenkins instance pod starting\nup on the Worker cluster."),(0,r.kt)("p",null,"Verify the Jenkins instance is booting up (it may take a couple of minutes, and\nit may go into a ",(0,r.kt)("em",{parentName:"p"},"Terminating")," a few times):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-worker get pods --watch\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"It will take a couple of minutes for Jenkins to start, and it may cycle through\na few states, including ",(0,r.kt)("em",{parentName:"p"},"Terminating"),", before it eventually succeeds.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"NAME                                READY   STATUS    RESTARTS   AGE\n//highlight-next-line\njenkins-dev-example                 0/1     Running   0          1m\njenkins-operator-7f58798d5c-sr825   1/1     Running   0          1h\n")),(0,r.kt)("p",null,"When the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ready")," column reports ",(0,r.kt)("inlineCode",{parentName:"p"},"1/1")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"jenkins-dev-example"),", your Jenkins\ninstance is fully deployed and ready to be accessed!"),(0,r.kt)("p",null,"Go to ",(0,r.kt)("a",{parentName:"p",href:"http://localhost:30269"},"http://localhost:30269")," and check it out!"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"If you gave your Jenkins a different name, you may need port-forwarding to\naccess the running instance:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl --context kind-worker port-forward pod/jenkins-dev-<NAME> 8080:30269\n"))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83e\udd14 Where are the Jenkins Credentials?"),(0,r.kt)("p",null,"To login to Jenkins, you will need to fetch the credentials on the Worker\ncluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl get secrets --context kind-worker --selector app=jenkins-operator -o go-template=\'{{range .items}}{{"username: "}}{{.data.user|base64decode}}{{"\\n"}}{{"password: "}}{{.data.password|base64decode}}{{"\\n"}}{{end}}\'\n'))),(0,r.kt)("h2",{id:"clean-up"},"Clean up"),(0,r.kt)("p",null,"We won't be using the Jenkins or the Jenkins Promise anymore. So let's go ahead\nand delete the resources."),(0,r.kt)("p",null,"Delete the Jenkins Promise:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context kind-platform delete promise jenkins\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},'promise.platform.kratix.io "jenkins" deleted\n')),(0,r.kt)("p",null,"The delete command will also cascade-delete all traces of Jenkins from our\nPlatform, including the deployed Jenkins on the Worker cluster."),(0,r.kt)("p",null,"Verify that the Jenkins instance gets deleted:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods --context kind-worker\n")),(0,r.kt)("p",null,"The above command will give an output similar to (it may take a few minutes):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"No resources found in default namespace.\n")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"To recap the steps we took:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Installed the Jenkins Promise"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Created and configured a Worker cluster"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Registered the Worker cluster with the Platform"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Requested a Jenkins instance")),(0,r.kt)("h2",{id:"--congratulations"},"\ud83c\udf89 ","\xa0"," Congratulations!"),(0,r.kt)("p",null,"\u2705","\xa0","\xa0","Your promise is now installed. ",(0,r.kt)("br",null),"\n\ud83d\udc49\ud83c\udffe","\xa0","\xa0","Next, let's learn more about th",(0,r.kt)("a",{parentName:"p",href:"promise-theory"},"e theory behind\nPromises")))}c.isMDXComponent=!0}}]);