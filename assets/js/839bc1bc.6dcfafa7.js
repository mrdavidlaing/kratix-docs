"use strict";(self.webpackChunkkratix_docs=self.webpackChunkkratix_docs||[]).push([[7690],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4205:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(7462),r=(n(7294),n(3905));const o={toc:[]};function i(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Before moving on, please clean up your environment by deleting the current Promises and Resources.\nKratix will, by default, clean up any Resources when the parent Promise is deleted."),(0,r.kt)("p",null,"To delete all the Promises, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context $PLATFORM delete promises --all\n")),(0,r.kt)("p",null,"The above command will give an output similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell-session"},"promise.platform.kratix.io/elastic-cloud deleted\n")))}i.isMDXComponent=!0},4051:(e,t,n)=>{n.d(t,{ZP:()=>i});var a=n(7462),r=(n(7294),n(3905));const o={toc:[{value:"Pre-requisites",id:"pre-requisites",level:4}]};function i(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},o,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h4",{id:"pre-requisites"},"Pre-requisites"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"You need an installation of Kratix for this section. ",(0,r.kt)("strong",null,"Click here")," for instructions"),(0,r.kt)("p",null,"The simplest way to do so is by running the quick-start script from within the\nKratix directory. The script will create two KinD clusters, install, and\nconfigure Kratix."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"./scripts/quick-start.sh --recreate\n")),(0,r.kt)("p",null,"You can run Kratix either with a multi-cluster or a single-cluster setup. The\ncommands on the remainder of this document assume that two environment variables\nare set:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"PLATFORM")," representing the Platform cluster Kubernetes context"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"WORKER")," representing the Worker cluster Kubernetes context")),(0,r.kt)("p",null,"If you ran the quick-start script above, do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'export PLATFORM="kind-platform"\nexport WORKER="kind-worker"\n')),(0,r.kt)("p",null,"For single cluster setups, the two variables should be set to the same value.\nYou can find your cluster context by running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"kubectl config get-contexts\n")),(0,r.kt)("p",null,"Refer back to ",(0,r.kt)("a",{parentName:"p",href:"../../category/installing-kratix"},"Installing Kratix")," for more\ndetails.")))}i.isMDXComponent=!0},1008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>g,frontMatter:()=>u,metadata:()=>m,toc:()=>h});var a=n(7462),r=(n(7294),n(3905)),o=n(4051),i=(n(4205),n(4996));const l=[{value:"Using Kratix to support your organisation",id:"using-kratix-to-support-your-organisation",level:2},{value:"From off-the-shelf to ready for the paved path",id:"from-off-the-shelf-to-ready-for-the-paved-path",level:2},{value:"The scenario",id:"the-scenario",level:3},{value:"Step one: Get a base Promise",id:"base-promise",level:3},{value:"Step two: <code>api</code>",id:"api",level:3},{value:"About <code>api</code>",id:"about-api",level:4},{value:"Update the <code>api</code>",id:"update-the-api",level:4},{value:"Step three: <code>dependencies</code>",id:"dependencies",level:3},{value:"About <code>dependencies</code>",id:"about-dependencies",level:4},{value:"Update <code>dependencies</code>",id:"update-dependencies",level:4},{value:"Step four: <code>workflows</code>",id:"workflows",level:3},{value:"About <code>workflows</code>",id:"about-workflows",level:4},{value:"Update the <code>minimal-postgres-manifest.yaml</code> to add in the property",id:"update-the-minimal-postgres-manifestyaml-to-add-in-the-property",level:4},{value:"Update the <code>execute-pipeline.sh</code> to add in the user&#39;s value",id:"update-the-execute-pipelinesh-to-add-in-the-users-value",level:4},{value:"Test the pipeline locally",id:"test-the-pipeline-locally",level:4},{value:"Give the platform access to your image",id:"give-the-platform-access-to-your-image",level:4},{value:"Update the Promise&#39;s <code>workflows</code> value",id:"update-the-promises-workflows-value",level:4},{value:"Step five: Install",id:"install-promise",level:3},{value:"Step six: Verify",id:"verify-resource",level:3},{value:"Verifying your Kratix Promise can be fulfilled",id:"verifying-your-kratix-promise-can-be-fulfilled",level:4},{value:"Validating the created Postgres",id:"validating-the-created-postgres",level:4},{value:"Summary",id:"summary",level:2},{value:"Clean up environment",id:"cleanup",level:2}],s={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"In this tutorial, you will")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"experience the power of leveraging customised Kratix Promises"),(0,r.kt)("li",{parentName:"ol"},"gain confidence with the components of a Promise"),(0,r.kt)("li",{parentName:"ol"},"enhance an sample Postgres Promise")),(0,r.kt)("h2",{id:"using-kratix-to-support-your-organisation"},"Using Kratix to support your organisation"),(0,r.kt)("p",null,"As ",(0,r.kt)("a",{parentName:"p",href:"./installing-a-promise"},"you've seen"),", Kratix can support Promises for services like Jenkins, Nginx, and Postgres."),(0,r.kt)("p",null,"When you think about providing services for things like automation, deployment or data, how often are you able to choose a service (like Postgres) and offer it to your users straight off the shelf?"),(0,r.kt)("p",null,"Probably not very often."),(0,r.kt)("p",null,"Application teams need to be able to easily run their services in different environments. They'll want specific sizes, particular backup strategies, defined versions, and more. Key stakeholders in other parts of the business also need to easily understand the state of service usage as it applies to them (hello audit, billing, and security!)."),(0,r.kt)("p",null,"Your team works with all of these users to understand the if, when, and how of each of these requests and creates a platform from a prioritised backlog of platform features."),(0,r.kt)("p",null,"This platform needs to be extensible and flexible","\u2014","your users will have new and changing needs, and you'll want to quickly respond to valuable feature requests."),(0,r.kt)("p",null,"Kratix and Promises make it easier to create a platform paved with golden paths that deliver value easily and quickly."),(0,r.kt)("p",null,"Now you will create and enhance a Promise as a response to user and business needs."),(0,r.kt)("br",null),(0,r.kt)("hr",null),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"from-off-the-shelf-to-ready-for-the-paved-path"},"From off-the-shelf to ready for the paved path"),(0,r.kt)("h3",{id:"the-scenario"},"The scenario"),(0,r.kt)("p",null,"In this exercise, you and the platform team are starting development of the next platform feature."),(0,r.kt)("p",null,"You discussed needs with application teams and you've decided to offer a new service. You'll be adding Postgres to your platform."),(0,r.kt)("p",null,"The billing team is a key stakeholder for the platform, and they will need a cost centre for each new Postgres Resource to charge back to the right team."),(0,r.kt)("p",null,"For the purposes of this exercise, you know that all of the underlying functionality to get the billing team what it needs is already in place."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"In this guide, you only need create a new Postgres Promise that creates Postgres Resources with a ",(0,r.kt)("inlineCode",{parentName:"em"},"costCentre")," label.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"The steps:")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#base-promise"},"Get a base Promise")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#api"},"Change the Promise so that ",(0,r.kt)("em",{parentName:"a"},"the user who wants an Resource")," knows they need to include their ",(0,r.kt)("inlineCode",{parentName:"a"},"costCentre")," name when they make their request to the platform")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#dependencies"},"Change the Promise so that ",(0,r.kt)("em",{parentName:"a"},"the Worker Cluster")," Operator that creates the Resource knows to apply your new ",(0,r.kt)("inlineCode",{parentName:"a"},"costCentre")," label ",(0,r.kt)("inlineCode",{parentName:"a"},"costCentre"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#workflow"},"Change the Promise so that ",(0,r.kt)("em",{parentName:"a"},"the Workflow")," knows how to add the user's ",(0,r.kt)("inlineCode",{parentName:"a"},"costCentre")," to the request for a Resource")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#install-promise"},"Install the modified Promise on your platform")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#verify-resource"},"Check it works: make a request to your platform for a Postgres Resource"))),(0,r.kt)("h3",{id:"base-promise"},"Step one: Get a base Promise"),(0,r.kt)("p",null,"There's a PostgreSQL Promise available on the ",(0,r.kt)("a",{parentName:"p",href:"http://kratix.io/marketplace"},"Marketplace"),". You'll use that as your base. Start by cloning the repository:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"git clone https://github.com/syntasso/promise-postgresql.git\n")),(0,r.kt)("p",null,"Take a look"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"cd promise-postgresql\nls\n")),(0,r.kt)("p",null,"You should see something a structure similar to the one below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},". \ud83d\udcc2 promise-postgresql\n#highlight-next-line\n  \u251c\u2500\u2500 promise.yaml\n  \u251c\u2500\u2500 resource-request.yaml\n  \u251c\u2500\u2500 ...\n  \u2514\u2500\u2500 \ud83d\udcc2 internal\n      \u251c\u2500\u2500 \ud83d\udcc2 configure-pipeline\n      \u2502   \u251c\u2500\u2500 \ud83d\udcc2 resources\n      \u2502   \u2502   \u2514\u2500\u2500 minimal-postgres-manifest.yaml\n      \u2502   \u251c\u2500\u2500 Dockerfile\n      \u2502   \u251c\u2500\u2500 execute-pipeline.sh\n      \u251c\u2500\u2500 \ud83d\udcc2 dependencies\n      \u2502   \u251c\u2500\u2500 operator.yaml\n      \u2502   \u2514\u2500\u2500 ...\n      \u251c\u2500\u2500 \ud83d\udcc2 scripts\n      \u2502   \u251c\u2500\u2500 test\n      \u2502   \u2514\u2500\u2500 ...\n      \u2514\u2500\u2500 README.md\n")),(0,r.kt)("p",null,"You should see the ",(0,r.kt)("inlineCode",{parentName:"p"},"promise.yaml")," file. This is the Promise definition\nthat you'll modify and install on your platform. Ignore everything else in the\nfolder for now."),(0,r.kt)("h3",{id:"api"},"Step two: ",(0,r.kt)("inlineCode",{parentName:"h3"},"api")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Change the Promise so that ",(0,r.kt)("em",{parentName:"p"},"the user who wants a Postgres")," knows they need to include their ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," name when they make their request to the platform")),(0,r.kt)("h4",{id:"about-api"},"About ",(0,r.kt)("inlineCode",{parentName:"h4"},"api")),(0,r.kt)("img",{align:"right",src:(0,i.Z)("/img/docs/api.png"),alt:"screenshot of a YAML file, highlighting the presence of the api key"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"api")," is the API exposed to the users of the ",(0,r.kt)("a",{parentName:"p",href:"writing-a-promise"},"Promise"),".\nTo see ",(0,r.kt)("inlineCode",{parentName:"p"},"api")," in the Promise definition file, open ",(0,r.kt)("inlineCode",{parentName:"p"},"promise.yaml"),"\nand look under the ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," section."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"api")," is the contract with the user who wants a Resource. It's where you get to define the required and optional configuration options exposed to your users."),(0,r.kt)("p",null,"You can already see a number of properties in this section of the ",(0,r.kt)("inlineCode",{parentName:"p"},"promise.yaml")," file. These properties are defined within a versioned schema and can have different types and validations."),(0,r.kt)("h4",{id:"update-the-api"},"Update the ",(0,r.kt)("inlineCode",{parentName:"h4"},"api")),(0,r.kt)("p",null,"To add the required cost centre configuration, add the following to the ",(0,r.kt)("inlineCode",{parentName:"p"},"promise.yaml"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'costCentre:\n  pattern: "^[a-zA-Z0-9_.-]*$"\n  type: string\n')),(0,r.kt)("p",null,"From the top of the file, navigate to"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"api")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"versions[0]")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"schema")," > ",(0,r.kt)("br",null)," ",(0,r.kt)("inlineCode",{parentName:"p"},"openAPIV3Schema")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"properties")),(0,r.kt)("p",null,"Here, add your ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," YAML from above as a sibling to the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"dbName")," property."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here to view a final version of the extended ",(0,r.kt)("code",null,"api")," which should be indented so as to nest under the ",(0,r.kt)("code",null,"spec")," header"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'api:\n  apiVersion: apiextensions.k8s.io/v1\n  kind: CustomResourceDefinition\n  metadata:\n    name: postgresqls.marketplace.kratix.io\n  spec:\n    group: marketplace.kratix.io\n    names:\n      kind: postgresql\n      plural: postgresqls\n      singular: postgresql\n    scope: Namespaced\n    versions:\n      - name: v1alpha1\n        schema:\n          openAPIV3Schema:\n            properties:\n              spec:\n                properties:\n                  #highlight-start\n                  costCentre:\n                    pattern: "^[a-zA-Z0-9_.-]*$"\n                    type: string\n                  #highlight-end\n                  dbName:\n                    default: postgres\n                    description: |\n                      Database name. A database will be created with this name. The owner of the database will be the teamId.\n                    type: string\n                  env:\n                    default: dev\n                    description: |\n                      Configures and deploys this PostgreSQL with environment specific configuration. Prod PostgreSQL are configured with backups and more resources.\n                    pattern: ^(dev|prod)$\n                    type: string\n                  teamId:\n                    default: acid\n                    description: |\n                      Team ID. A superuser role will be created with this name.\n                    type: string\n                type: object\n            type: object\n        served: true\n        storage: true\n'))),(0,r.kt)("h3",{id:"dependencies"},"Step three: ",(0,r.kt)("inlineCode",{parentName:"h3"},"dependencies")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Change the Promise so that ",(0,r.kt)("em",{parentName:"p"},"the Worker")," that can host the Postgres knows to apply your new ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," label ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre"))),(0,r.kt)("h4",{id:"about-dependencies"},"About ",(0,r.kt)("inlineCode",{parentName:"h4"},"dependencies")),(0,r.kt)("img",{align:"right",src:(0,i.Z)("/img/docs/dependencies.png"),alt:"screenshot of a YAML file, highlighting the presence of the dependencies key"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," is the description of all of the Kubernetes resources required to create a promised Resource, such as CRDs, Operators and Deployments."),(0,r.kt)("p",null,"In the Promise definition, you divide resources based on the idea of ",(0,r.kt)("em",{parentName:"p"},"prerequisite")," and ",(0,r.kt)("em",{parentName:"p"},"per-resource")," items. Prerequisite resources are resources that we create before any application team requests a Resource. This can be helpful for two scenarios:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Any CRDs or dependencies are ready when an Resource is requested which speeds up response time to application teams."),(0,r.kt)("li",{parentName:"ol"},"Resources that can be shared across Resources are only deployed once. This can reduce load on the cluster, and it can also allow delivering a Resource as a portion of an existing Resource (e.g. you could provide a whole database instance on each request, or you could provide a database within an existing instance on each request)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies")," section of the Kratix Promise defines the ",(0,r.kt)("em",{parentName:"p"},"prerequisite capabilities"),"."),(0,r.kt)("p",null,"These capabilities are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"created once per cluster."),(0,r.kt)("li",{parentName:"ul"},"complete Kubernetes YAML documents stored in the ",(0,r.kt)("inlineCode",{parentName:"li"},"dependencies")," section of the Promise.")),(0,r.kt)("p",null,"For the Postgres Promise you're defining, the only cluster resources (prerequisite capabilities) you need are conveniently packaged in a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zalando/postgres-operator"},"Kubernetes Operator")," that is maintained by Zalando. The Operator turns the complexities of configuring Postgres into a manageable configuration format."),(0,r.kt)("h4",{id:"update-dependencies"},"Update ",(0,r.kt)("inlineCode",{parentName:"h4"},"dependencies")),(0,r.kt)("p",null,"To make sure all Postgres Resources includes ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre"),", you need to make the Operator aware of the label."),(0,r.kt)("p",null,"To ensure Zalando's Postgres Operator is aware of the label, you need to add configuration when installing the Operator. The configuration the Operator needs will be under a new key: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zalando/postgres-operator/blob/master/docs/reference/operator_parameters.md#kubernetes-resources?:=inherited_labels"},(0,r.kt)("inlineCode",{parentName:"a"},"inherited_labels")),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"inherited_labels")," is unique to how Zalando's Postgres Operator works. If you were using a different Operator (or writing your own!), a different change may be required (or no change at all).")),(0,r.kt)("p",null,"Following the Zalando ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zalando/postgres-operator/blob/master/docs/reference/operator_parameters.md#kubernetes-resources?:=inherited_labels"},(0,r.kt)("inlineCode",{parentName:"a"},"docs")),", you need to add ",(0,r.kt)("inlineCode",{parentName:"p"},"inherited_labels")," in a particular spot."),(0,r.kt)("p",null,"From the top of the file, navigate to"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"dependencies[7]")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"configuration")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"kubernetes")),(0,r.kt)("p",null,"To verify you're in the right place, the object should be ",(0,r.kt)("inlineCode",{parentName:"p"},"kind: OperatorConfiguration")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"name: postgres-operator"),"."),(0,r.kt)("p",null,"Under the ",(0,r.kt)("inlineCode",{parentName:"p"},"kubernetes")," key, add ",(0,r.kt)("inlineCode",{parentName:"p"},"inherited_labels: [costCentre]"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here to see the complete ",(0,r.kt)("code",null,"OperatorConfiguration")," resource after this change"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'# Note, the property was added to the top of the configuration.kubernetes\n- apiVersion: acid.zalan.do/v1\n  configuration:\n    aws_or_gcp:\n      aws_region: eu-central-1\n      enable_ebs_gp3_migration: false\n    connection_pooler:\n      connection_pooler_default_cpu_limit: "1"\n      connection_pooler_default_cpu_request: 500m\n      connection_pooler_default_memory_limit: 100Mi\n      connection_pooler_default_memory_request: 100Mi\n      connection_pooler_image: registry.opensource.zalan.do/acid/pgbouncer:master-22\n      connection_pooler_max_db_connections: 60\n      connection_pooler_mode: transaction\n      connection_pooler_number_of_instances: 2\n      connection_pooler_schema: pooler\n      connection_pooler_user: pooler\n    crd_categories:\n      - all\n    debug:\n      debug_logging: true\n      enable_database_access: true\n    docker_image: registry.opensource.zalan.do/acid/spilo-14:2.1-p6\n    enable_crd_registration: true\n    enable_lazy_spilo_upgrade: false\n    enable_pgversion_env_var: true\n    enable_shm_volume: true\n    enable_spilo_wal_path_compat: false\n    etcd_host: ""\n    kubernetes:\n      #highlight-next-line\n      inherited_labels: [costCentre]\n      cluster_domain: cluster.local\n      cluster_labels:\n        application: spilo\n      cluster_name_label: cluster-name\n      enable_cross_namespace_secret: false\n      enable_init_containers: true\n      enable_pod_antiaffinity: false\n      enable_pod_disruption_budget: true\n      enable_sidecars: true\n      oauth_token_secret_name: postgres-operator\n      pdb_name_format: postgres-{cluster}-pdb\n      pod_antiaffinity_topology_key: kubernetes.io/hostname\n      pod_management_policy: ordered_ready\n      pod_role_label: spilo-role\n      pod_service_account_name: postgres-pod\n      pod_terminate_grace_period: 5m\n      secret_name_template: "{username}.{cluster}.credentials.{tprkind}.{tprgroup}"\n      spilo_allow_privilege_escalation: true\n      spilo_privileged: false\n      storage_resize_mode: pvc\n      watched_namespace: "*"\n    load_balancer:\n      db_hosted_zone: db.example.com\n      enable_master_load_balancer: false\n      enable_master_pooler_load_balancer: false\n      enable_replica_load_balancer: false\n      enable_replica_pooler_load_balancer: false\n      external_traffic_policy: Cluster\n      master_dns_name_format: "{cluster}.{team}.{hostedzone}"\n      replica_dns_name_format: "{cluster}-repl.{team}.{hostedzone}"\n    logging_rest_api:\n      api_port: 8080\n      cluster_history_entries: 1000\n      ring_log_lines: 100\n    logical_backup:\n      logical_backup_docker_image: registry.opensource.zalan.do/acid/logical-backup:v1.8.0\n      logical_backup_job_prefix: logical-backup-\n      logical_backup_provider: s3\n      logical_backup_s3_access_key_id: ""\n      logical_backup_s3_bucket: my-bucket-url\n      logical_backup_s3_endpoint: ""\n      logical_backup_s3_region: ""\n      logical_backup_s3_retention_time: ""\n      logical_backup_s3_secret_access_key: ""\n      logical_backup_s3_sse: AES256\n      logical_backup_schedule: 30 00 * * *\n    major_version_upgrade:\n      major_version_upgrade_mode: "off"\n      minimal_major_version: "9.6"\n      target_major_version: "14"\n    max_instances: -1\n    min_instances: -1\n    postgres_pod_resources:\n      default_cpu_limit: "1"\n      default_cpu_request: 100m\n      default_memory_limit: 500Mi\n      default_memory_request: 100Mi\n      min_cpu_limit: 250m\n      min_memory_limit: 250Mi\n    repair_period: 5m\n    resync_period: 30m\n    teams_api:\n      enable_admin_role_for_users: true\n      enable_postgres_team_crd: false\n      enable_postgres_team_crd_superusers: false\n      enable_team_member_deprecation: false\n      enable_team_superuser: false\n      enable_teams_api: false\n      pam_role_name: zalandos\n      postgres_superuser_teams:\n        - postgres_superusers\n      protected_role_names:\n        - admin\n        - cron_admin\n      role_deletion_suffix: _deleted\n      team_admin_role: admin\n      team_api_role_configuration:\n        log_statement: all\n    timeouts:\n      patroni_api_check_interval: 1s\n      patroni_api_check_timeout: 5s\n      pod_deletion_wait_timeout: 10m\n      pod_label_wait_timeout: 10m\n      ready_wait_interval: 3s\n      ready_wait_timeout: 30s\n      resource_check_interval: 3s\n      resource_check_timeout: 10m\n    users:\n      enable_password_rotation: false\n      password_rotation_interval: 90\n      password_rotation_user_retention: 180\n      replication_username: standby\n      super_username: postgres\n    workers: 8\n  kind: OperatorConfiguration\n  metadata:\n    labels:\n      app.kubernetes.io/instance: postgres-operator\n      app.kubernetes.io/managed-by: Helm\n      app.kubernetes.io/name: postgres-operator\n      helm.sh/chart: postgres-operator-1.8.2\n    name: postgres-operator\n    namespace: default\n'))),(0,r.kt)("h3",{id:"workflows"},"Step four: ",(0,r.kt)("inlineCode",{parentName:"h3"},"workflows")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Change the Promise ",(0,r.kt)("inlineCode",{parentName:"p"},"resource.configure")," Workflow so that the image knows how to add the user's ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," to the request for the Resource.")),(0,r.kt)("h4",{id:"about-workflows"},"About ",(0,r.kt)("inlineCode",{parentName:"h4"},"workflows")),(0,r.kt)("img",{align:"right",src:(0,i.Z)("img/docs/xaasRequestPipeline.png"),alt:"screenshot of a YAML file, highlighting the presence of the Workflow key"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"workflows.resource.configure")," contains a Kratix Pipeline that will take your user's request, apply rules from your organisation (including adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," name), and output valid Kubernetes documents for the Operator to run on a Worker Cluster."),(0,r.kt)("p",null,"Conceptually, a configure Pipeline is a sequential set of steps that transforms an input value to generate an output value. There are three parts to the PostgreSQL Pipeline."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resources/minimal-postgres-manifest.yaml")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execute-pipeline.sh")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Dockerfile"))),(0,r.kt)("br",null),(0,r.kt)("p",null,"You can see these files in the ",(0,r.kt)("inlineCode",{parentName:"p"},"internal/configure-pipeline")," directory. To\nconnect the new user input label, we will need to make sure the image both\nreads it in from the API input, and applies it to the right place in the customised resource outputs."),(0,r.kt)("p",null,"This requires you to change two of files:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Template: This template needs to hold reference to the ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," ",(0,r.kt)("em",{parentName:"li"},"label")),(0,r.kt)("li",{parentName:"ol"},"Pipeline script: Inject the user's ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," ",(0,r.kt)("em",{parentName:"li"},"actual value")," into the resource template to generate the output")),(0,r.kt)("h4",{id:"update-the-minimal-postgres-manifestyaml-to-add-in-the-property"},"Update the ",(0,r.kt)("inlineCode",{parentName:"h4"},"minimal-postgres-manifest.yaml")," to add in the property"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"minimal-postgres-manifest.yaml")," is the basic template for a Postgres. This is a valid Kubernetes document that the Postgres Operator can understand."),(0,r.kt)("p",null,"You know every Postgres Resource needs the ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre"),". Change the metadata in ",(0,r.kt)("inlineCode",{parentName:"p"},"minimal-postgres-manifest.yaml")," to include the ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," label. This sets up a holding spot for the ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," value the user sends in the request."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"jsx title=promise-postgresql/internal/configure-pipeline/resources/minimal-postgres-manifest.yaml",jsx:!0,title:"promise-postgresql/internal/configure-pipeline/resources/minimal-postgres-manifest.yaml"},"labels:\n  costCentre: TBD\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here for the complete metadata section"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:"jsx title=promise-postgresql/internal/configure-pipeline/resources/minimal-postgres-manifest.yaml",jsx:!0,title:"promise-postgresql/internal/configure-pipeline/resources/minimal-postgres-manifest.yaml"},"metadata:\n  name: acid-minimal-cluster\n  labels:\n    costCentre: TBD\n"))),(0,r.kt)("h4",{id:"update-the-execute-pipelinesh-to-add-in-the-users-value"},"Update the ",(0,r.kt)("inlineCode",{parentName:"h4"},"execute-pipeline.sh")," to add in the user's value"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"execute-pipeline.sh")," (in ",(0,r.kt)("inlineCode",{parentName:"p"},"promise-postgresql/internal/configure-pipeline"),")\nruns when Kubernetes schedules the Pipeline. This script is where the transformation logic lives."),(0,r.kt)("p",null,"You can see that the script is already parsing the request to\nidentify key user variables (",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"namespace"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"teamId"),", etc). The\nscript then uses ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mikefarah/yq"},"yq")," to add those\nuser-provided values to the output document. You can do the same to process the\nuser's ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre"),"."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"execute-pipeline.sh")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Export another environment variable to store the value",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"export COST_CENTRE=$(yq eval '.spec.costCentre' /kratix/input/object.yaml)\n"))),(0,r.kt)("li",{parentName:"ol"},"Add a new line for ",(0,r.kt)("inlineCode",{parentName:"li"},"yq")," process the label replacement",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-bash"},".metadata.labels.costCentre = env(COST_CENTRE) |\n")))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here to view an example of the final script"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash",metastring:"jsx title=promise-postgresql/internal/configure-pipeline/execute-pipeline.sh",jsx:!0,title:"promise-postgresql/internal/configure-pipeline/execute-pipeline.sh"},'#!/usr/bin/env sh\n\nset -x\n\nbase_instance="/tmp/transfer/minimal-postgres-manifest.yaml"\n\n# Read current values from the provided request\nname="$(yq eval \'.metadata.name\' /kratix/input/object.yaml)"\n\nenv_type="$(yq eval \'.spec.env // "dev"\' /kratix/input/object.yaml)"\nteam="$(yq eval \'.spec.teamId // "acid"\' /kratix/input/object.yaml)"\ndbname="$(yq eval \'.spec.dbName // "postgres"\' /kratix/input/object.yaml)"\n\ninstance_name="${team}-${name}-postgresql"\n\nbackup="false"\nsize="1Gi"\ninstances="1"\nif [ $env_type = "prod" ]; then\n  backup="true"\n  size="10Gi"\n  instances="3"\nfi\n\n#highlight-next-line\nexport COST_CENTRE=$(yq eval \'.spec.costCentre\' /kratix/input/object.yaml)\n\n# Replace defaults with user provided values\ncat ${base_instance} |\n  yq eval "\n  #highlight-next-line\n    .metadata.labels.costCentre = env(COST_CENTRE) |\n    .metadata.namespace = \\"default\\" |\n    .metadata.name = \\"${instance_name}\\" |\n    .spec.enableLogicalBackup = ${backup} |\n    .spec.teamId = \\"${team}\\" |\n    .spec.volume.size = \\"${size}\\" |\n    .spec.numberOfInstances = ${instances} |\n    .spec.users = {\\"${team}\\": [\\"superuser\\", \\"createdb\\"]} |\n    .spec.databases = {\\"$dbname\\": \\"$team\\"} |\n    del(.spec.preparedDatabases)\n  " - > /kratix/output/postgres-instance.yaml\n'))),(0,r.kt)("h4",{id:"test-the-pipeline-locally"},"Test the pipeline locally"),(0,r.kt)("p",null,"You can easily validate your pipeline locally by building and running the Docker image with the correct volume mounts."),(0,r.kt)("p",null,"Check that you are in the ",(0,r.kt)("inlineCode",{parentName:"p"},"promise-postgresql")," directory, and run the block below to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"create two directories inside ",(0,r.kt)("inlineCode",{parentName:"li"},"internal/configure-pipeline"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"input")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"output")),(0,r.kt)("li",{parentName:"ol"},"create expected input file (i.e., the request from your user)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},'cd internal/configure-pipeline\nmkdir -p {input,output}\ncat > input/object.yaml <<EOF\n---\napiVersion: marketplace.kratix.io/v1alpha1\nkind: postgresql\nmetadata:\n  name: example\n  namespace: default\nspec:\n  costCentre: "rnd-10002"\n  env: dev\n  teamId: acid\n  dbName: bestdb\nEOF\n')),(0,r.kt)("p",null,"Now test the pipeline by doing a Docker build and run. ",(0,r.kt)("em",{parentName:"p"},"Check that, per the step above, you are still in the ",(0,r.kt)("inlineCode",{parentName:"em"},"internal/configure-pipeline")," directory.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"docker build . --tag kratix-workshop/postgres-configure-pipeline:dev\ndocker run -v ${PWD}/input:/kratix/input -v ${PWD}/output:/kratix/output kratix-workshop/postgres-configure-pipeline:dev\n")),(0,r.kt)("p",null,"Now you can validate the ",(0,r.kt)("inlineCode",{parentName:"p"},"output/postgres-instance.yaml")," file."),(0,r.kt)("p",null,"It should be the base manifest with all the custom values inserted and look like the example below. If your output is different, go back and check the steps from above and the files in the directory. Repeat this process until your output matches the output below."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here to view an example of expected output YAML"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'jsx title="expected promise-postgresql/internal/configure-pipeline/kratix/output/postgres-instance.yaml"',jsx:!0,title:'"expected','promise-postgresql/internal/configure-pipeline/kratix/output/postgres-instance.yaml"':!0},'apiVersion: "acid.zalan.do/v1"\nkind: postgresql\nmetadata:\n  name: acid-example-postgresql\n  labels:\n    costCentre: "rnd-10002"\nspec:\n  teamId: "acid"\n  volume:\n    size: 1Gi\n  numberOfInstances: 1\n  users:\n    acid:\n      - superuser\n      - createdb\n  databases:\n    bestdb: acid\n  postgresql:\n    version: "15"\n  enableLogicalBackup: false\n'))),(0,r.kt)("h4",{id:"give-the-platform-access-to-your-image"},"Give the platform access to your image"),(0,r.kt)("p",null,"Once you have made and validated all the image changes, you will need\nto make the newly created ",(0,r.kt)("inlineCode",{parentName:"p"},"kratix-workshop/postgres-configure-pipeline:dev")," image\naccessible."),(0,r.kt)("p",null,"If you created your clusters with KinD, you can load the image into local cache\nby running the command below. This will stop any remote DockerHub calls."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kind load docker-image kratix-workshop/postgres-configure-pipeline:dev --name platform\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("strong",null,"Click here")," if your clusters were not created with KinD"),"If you have not created your Kubernetes clusters with KinD, you will need to either:",(0,r.kt)("ul",null,(0,r.kt)("li",null,"Push the image to a Image repository (like Dockerhub), or "),(0,r.kt)("li",null,"Use the appropriate command to load the image (for example, ",(0,r.kt)("code",null,"minikube cache add")," if you are using minikube)"))),(0,r.kt)("h4",{id:"update-the-promises-workflows-value"},"Update the Promise's ",(0,r.kt)("inlineCode",{parentName:"h4"},"workflows")," value"),(0,r.kt)("p",null,"The new image is built and available on your Platform Cluster. Update your Promise to use the new image."),(0,r.kt)("p",null,"Open the Promise definition file (",(0,r.kt)("inlineCode",{parentName:"p"},"promise-postgresql/promise.yaml"),"). From the top of the file, navigate to ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"workflows")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"resource")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"configure[0]")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"containers[0]")," > ",(0,r.kt)("inlineCode",{parentName:"p"},"image")," and replace the current value image with the newly created ",(0,r.kt)("inlineCode",{parentName:"p"},"kratix-workshop/postgres-configure-pipeline:dev")," image."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here to see the resulting Workflows section which should be indented under ",(0,r.kt)("code",null,"spec")," in the Promise yaml"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'jsx title="promise-postgresql/promise.yaml"',jsx:!0,title:'"promise-postgresql/promise.yaml"'},"apiVersion: platform.kratix.io/v1alpha1\nkind: Promise\nmetadata:\n  name: postgresql\nspec:\n  api:\n  # ...\n  workflows:\n    resource:\n      configure:\n        - apiVersion: platform.kratix.io/v1alpha1\n          kind: Pipeline\n          metadata:\n            name: configure-instance\n          spec:\n            containers:\n              - name: pipeline-stage-0\n                #highlight-next-line\n                image: kratix-workshop/postgres-configure-pipeline:dev\n  dependencies:\n  # ...\n"))),(0,r.kt)("h3",{id:"install-promise"},"Step five: Install"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Install the modified Promise on your platform")),(0,r.kt)("p",null,"You can now install your enhanced Postgres Promise on your platform. Make sure you're in the ",(0,r.kt)("inlineCode",{parentName:"p"},"promise-postgresql/")," directory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $PLATFORM apply --filename promise.yaml\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"Check that your Promise's resource is available."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $PLATFORM get crds\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"You should see something similar to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"NAME                                     CREATED AT\nclusters.platform.kratix.io              2022-08-09T14:35:54Z\n# highlight-next-line\npostgresqls.marketplace.kratix.io        2022-08-09T14:54:26Z\npromises.platform.kratix.io              2022-08-09T14:35:54Z\nworkplacements.platform.kratix.io        2022-08-09T14:35:54Z\nworks.platform.kratix.io                 2022-08-09T14:35:55Z\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"Check that the `dependencies` have been installed on the worker:",(0,r.kt)("br",null),(0,r.kt)("sub",null,"(This may take a few minutes so ",(0,r.kt)("code",null,"--watch")," will watch the command. Press ",(0,r.kt)("kbd",null,"Ctrl"),"+",(0,r.kt)("kbd",null,"C")," to stop watching)")),(0,r.kt)("p",null,"For Postgres, you can see in the Promise file that there are a number of RBAC\nresources, as well as a deployment that installs the Postgres Operator in the\nWorker Cluster. That means that when the Promise is successfully applied you\nwill see the ",(0,r.kt)("inlineCode",{parentName:"p"},"postgres-operator")," deployment in the Worker Cluster. That's also\nan indication that the Operator is ready to provision a new Postgres."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $WORKER --namespace default get pods\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"You should see something similar to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"NAME                                 READY   STATUS    RESTARTS   AGE\npostgres-operator-6c6dbd4459-hcsg2   1/1     Running   0          1m\n")),(0,r.kt)("br",null),(0,r.kt)("p",null,"You have successfully released a new platform capability! Your users can request a Postgres Resource, and that Postgres will include their ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre"),"."),(0,r.kt)("h3",{id:"verify-resource"},"Step six: Verify"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Check it works: make a request to your platform for a Postgres Resource")),(0,r.kt)("h4",{id:"verifying-your-kratix-promise-can-be-fulfilled"},"Verifying your Kratix Promise can be fulfilled"),(0,r.kt)("p",null,"Switching hats to test your release, now act as one of your users to make sure the Promise creates working Resource."),(0,r.kt)("p",null,"You need to create a request for a Resource, which is a valid Kubernetes\nresource. Like all Kubernetes resources, this must include all ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields"},"required\nfields"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"apiVersion")," where the resource can be found. This is ",(0,r.kt)("inlineCode",{parentName:"li"},"marketplace.kratix.io/v1alpha1")," in your Postgres Promise (from ",(0,r.kt)("inlineCode",{parentName:"li"},"spec.api.spec.group")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"promise.yaml"),")."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"kind"),". This is ",(0,r.kt)("inlineCode",{parentName:"li"},"postgresql")," in your Postgres Promise (from ",(0,r.kt)("inlineCode",{parentName:"li"},"spec.api.spec.name")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"promise.yaml"),")."),(0,r.kt)("li",{parentName:"ol"},"Values for required fields. Fields are ",(0,r.kt)("inlineCode",{parentName:"li"},"teamId"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"env"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"dbName")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," in your Postgres Promise (from ",(0,r.kt)("inlineCode",{parentName:"li"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"api")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"versions"),"[0]"," > ",(0,r.kt)("inlineCode",{parentName:"li"},"schema")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"openAPIV3Schema")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"properties")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"spec")," > ",(0,r.kt)("inlineCode",{parentName:"li"},"properties")," in ",(0,r.kt)("inlineCode",{parentName:"li"},"promise.yaml"),")."),(0,r.kt)("li",{parentName:"ol"},"A unique name and namespace combination.")),(0,r.kt)("p",null,"In the sample request (",(0,r.kt)("inlineCode",{parentName:"p"},"promise-postgresql/resource-request.yaml"),") add\nthe additional ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," field as a sibling to the other fields under ",(0,r.kt)("inlineCode",{parentName:"p"},"spec"),"\nwith any valid input. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},'costCentre: "rnd-10002"'),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"\ud83d\udc40\xa0\xa0Click here for the full Postgres Resource definition"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'jsx title="promise-postgresql/resource-request.yaml"',jsx:!0,title:'"promise-postgresql/resource-request.yaml"'},'apiVersion: marketplace.kratix.io/v1alpha1\nkind: postgresql\nmetadata:\n  name: example\n  namespace: default\nspec:\n  costCentre: "rnd-10002"\n  env: dev\n  teamId: acid\n  dbName: bestdb\n'))),(0,r.kt)("p",null,"Then apply the request file to the Platform Cluster:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $PLATFORM apply --filename resource-request.yaml\n")),(0,r.kt)("p",null,"We will validate the outcomes of this command in the next section."),(0,r.kt)("h4",{id:"validating-the-created-postgres"},"Validating the created Postgres"),(0,r.kt)("p",null,"Back as a platform engineer, you want to ensure that the platform and Promise\nbehaved as it should when creating the Resources and that the Resources have\nmet the requirements for the feature."),(0,r.kt)("p",null,"After you applied the request in the step above, you should\neventually see a new pod executing the\n",(0,r.kt)("inlineCode",{parentName:"p"},"execute-pipeline.sh")," script you created."),(0,r.kt)("p",null,"Check by listing the pods on the platform:",(0,r.kt)("br",null),(0,r.kt)("sub",null,"(This may take a few minutes so ",(0,r.kt)("code",null,"--watch")," will watch the command. Press ",(0,r.kt)("kbd",null,"Ctrl"),"+",(0,r.kt)("kbd",null,"C")," to stop watching)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $PLATFORM get pods --watch\n")),(0,r.kt)("p",null,"You should see something similar to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"NAME                                          READY   STATUS      RESTARTS   AGE\nconfigure-pipeline-postgresql-default-SHA     0/1     Completed   0          1h\n")),(0,r.kt)("p",null,"Then view the Pipeline logs by running ",(0,r.kt)("em",{parentName:"p"},"(replace SHA with the value from the output of ",(0,r.kt)("inlineCode",{parentName:"em"},"get pods")," above)"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $PLATFORM logs --container xaas-configure-pipeline-stage-0 pods/configure-pipeline-postgresql-default-SHA\n")),(0,r.kt)("p",null,"On the Worker Cluster, you will eventually see a Postgres service as a two-pod cluster in the ",(0,r.kt)("em",null,"Running")," state with the name defined by the Resource definition (",(0,r.kt)("code",null,"postgres-resource-request.yaml"),").",(0,r.kt)("br",null),(0,r.kt)("sub",null,"(This may take a few minutes so ",(0,r.kt)("code",null,"--watch")," will watch the command. Press ",(0,r.kt)("kbd",null,"Ctrl"),"+",(0,r.kt)("kbd",null,"C")," to stop watching)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $WORKER get pods --watch\n")),(0,r.kt)("p",null,"You should see something similar to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME                             READY   STATUS    RESTARTS   AGE\nacid-example-postgresql-0        1/1     Running   0          1h\n...\n")),(0,r.kt)("p",null,"For the finance team, the pods will provide cost tracking through your new ",(0,r.kt)("inlineCode",{parentName:"p"},"costCentre")," label. This can be confirmed by only selecting pods that contain the provided cost centre value:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $WORKER get pods --selector costCentre=rnd-10002\n")),(0,r.kt)("p",null,"You should see something similar to"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME                          READY   STATUS    RESTARTS   AGE\nacid-example-postgresql-0     1/1     Running   0          1h\n")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"Your platform has a new Promise. Your users have access to a new service from\nthe Promise. Your finance team has the ability to track service usage. Well\ndone!"),(0,r.kt)("p",null,"To recap the steps we took:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Acquired a base Promise"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Changed the Promise so that ",(0,r.kt)("em",{parentName:"li"},"the user who wants a Postgres")," knows they need to include their ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," name when they make their request to the platform"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Changed the Promise so that ",(0,r.kt)("em",{parentName:"li"},"the Worker Cluster")," Operator that creates the Resource knows to apply the new ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," label ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Changed the Promise so that ",(0,r.kt)("em",{parentName:"li"},"the Workflow")," knows how to add the user's ",(0,r.kt)("inlineCode",{parentName:"li"},"costCentre")," to the request for the Postgres"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Installed the modified Promise on your platform"),(0,r.kt)("li",{parentName:"ol"},"\u2705","\xa0","\xa0","Checked it works: make a request to your platform for a Postgres Resource")),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"cleanup"},"Clean up environment"),(0,r.kt)("p",null,"To clean up your environment first delete your request for the Postgres Resource"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context $PLATFORM delete --filename resource-request.yaml\n")),(0,r.kt)("p",null,"Verify the workloads belonging to the request have been deleted in the Worker Cluster"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $WORKER get pods\n")),(0,r.kt)("p",null,"Now that the Resource has been deleted you can delete the Promise"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl --context $PLATFORM delete --filename promise.yaml\n")),(0,r.kt)("p",null,"Verify the Dependencies are deleted from the Worker Cluster"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-console"},"kubectl --context $WORKER get pods\n")))}p.isMDXComponent=!0;const u={description:"Learn how to extend an existing Promise, from updating the API to changing the Workflow behaviour",title:"Enhancing a Promise"},c=void 0,m={unversionedId:"main/guides/enhancing-a-promise",id:"main/guides/enhancing-a-promise",title:"Enhancing a Promise",description:"Learn how to extend an existing Promise, from updating the API to changing the Workflow behaviour",source:"@site/docs/main/04-guides/05-enhancing-a-promise.md",sourceDirName:"main/04-guides",slug:"/main/guides/enhancing-a-promise",permalink:"/docs/main/guides/enhancing-a-promise",draft:!1,editUrl:"https://github.com/syntasso/kratix-docs/tree/main/docs/main/04-guides/05-enhancing-a-promise.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{description:"Learn how to extend an existing Promise, from updating the API to changing the Workflow behaviour",title:"Enhancing a Promise"},sidebar:"mainSidebar",previous:{title:"Writing a Promise",permalink:"/docs/main/guides/writing-a-promise"},next:{title:"Adding a new Worker",permalink:"/docs/main/guides/scheduling-clusters"}},d={},h=[...l],k={toc:h};function g(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(o.ZP,{mdxType:"PartialPreRequisites"}),(0,r.kt)(p,{mdxType:"EnhancingPromise"}),(0,r.kt)("p",{style:{"font-size":"2rem"}},(0,r.kt)("strong",null,"\ud83c\udf89 Congratulations!")),(0,r.kt)("p",null,"\u2705","\xa0","\xa0"," You have enhanced a Kratix Promise to suit your organisation's needs. ",(0,r.kt)("br",null),"\n\ud83d\udc49\ud83c\udffe","\xa0","\xa0"," Let's ",(0,r.kt)("a",{parentName:"p",href:"./scheduling-clusters"},"add a new Worker Cluster"),"."))}g.isMDXComponent=!0}}]);